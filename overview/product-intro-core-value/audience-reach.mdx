---
title: "Target Audience"
description: "Identify the intended users—developers and engineering teams leveraging Go's `database/sql` interface and seeking deep visibility into DB interactions, performance, and errors with OTel. Guidance on when otelsql is the right fit."
---

# Target Audience

Understanding exactly who benefits most from otelsql helps you determine if this instrumentation library fits your development and operational needs. This page clarifies the ideal users, their goals, and contextual scenarios where otelsql is your best choice.

---

## Who Is otelsql For?

- **Go Developers** using the `database/sql` package who want to seamlessly add observability without replacing existing database code.
- **Engineering Teams** seeking deep visibility into their SQL database interactions—tracing, latency measurement, error capture—within distributed systems.
- **SREs and Observability Engineers** responsible for monitoring production databases and ensuring performance SLAs through reliable telemetry.
- **Project Architects and Leads** evaluating instrumentation strategies for Go applications that depend on relational databases.

In short, if your codebase relies on Go’s standard database/sql interface and you want to unlock powerful OpenTelemetry insights with minimal friction, otelsql is designed for you.

---

## What Problems Does otelsql Help You Solve?

When using databases in Go, gaining observability often requires invasive changes or external probes. otelsql enables you to:

- Trace every database query and operation transparently, linked into your distributed trace data.
- Collect rich metrics around connection pools, query duration, errors, and more—turning opaque database calls into measurable events.
- Detect and diagnose performance bottlenecks and failures in SQL operations with precise context.

This clarity empowers troubleshooting, performance tuning, and enhancing user experience.

---

## When Should You Choose otelsql?

Consider otelsql if you seek the following outcomes:

- **Non-disruptive Integration:** You want to keep using Go’s native `database/sql` interfaces without rewriting or major refactoring.
- **Comprehensive Telemetry:** You need both tracing and metrics from your database layer that automatically correlate with your application traces.
- **OpenTelemetry Ecosystem Alignment:** Your observability architecture uses or plans to use OpenTelemetry collectors, compatible exporters, and the broader OTel ecosystem.
- **Customizable and Performant:** You require sensible defaults that follow best practices but also want options to fine-tune instrumentation based on your workload.

If your project is primarily in another language, or you use a completely different database access pattern (e.g., raw network queries without database/sql), other tools could be more suitable.

---

## Typical User Profiles & Scenarios

### 1. Backend Engineer in a Microservices Environment

Jane works on a Go service accessing a MySQL database via `database/sql`. Her team has adopted OpenTelemetry for tracing requests end-to-end. Adding otelsql allows Jane to instantly visualize every SQL operation within the trace timeline without changing any database call logic. When latency spikes, Jane pinpoints slow queries and connection pool stalls.

### 2. Site Reliability Engineer Monitoring Production

Raj maintains the observability dashboards of multiple services. Integrating otelsql metrics into their Prometheus stack gives Raj detailed insights into database health metrics like open connections and SQL errors. Alerts based on these metrics reduce mean-time-to-detection for database outages.

### 3. Team Lead Planning Observability Strategy

Maria evaluates instrumentation options for a migrating Go codebase. She selects otelsql because it covers essential telemetry use cases out of the box and aligns with their OpenTelemetry collector infrastructure. It enables progressive adoption across teams without heavy lift.

---

## Common Pitfalls & How otelsql Addresses Them

- **Worry: "Will I need to change all my SQL code?"

  **Reality:** otelsql wraps your existing `*sql.DB` or `*sql.Tx` instances transparently. Calls look and behave as before, but with added telemetry.

- **Worry: "Does this add latency or resource overhead?"

  **Reality:** otelsql uses efficient batching and best practices to minimize performance impact while delivering valuable signals.

- **Worry: "How do I handle indirect or autogenerated dependencies?"

  **Reality:** Using configuration options, you can enable or disable instrumentation selectively. For example, pinning digests for GitHub Actions or grouping indirect dependencies.

---

## Next Steps

- Review the [What is otelsql?](../product-intro-core-value/what-is-otelsql) page for foundational understanding.
- Explore [Value Proposition & Primary Use Cases](../product-intro-core-value/value-proposition-use-cases) to contextualize how otelsql fits your project objectives.
- Proceed to [Configuration Basics](../../getting-started/configuration-usage/basic-configuration) to start integrating otelsql in your application.


---

<Info>
Choosing the right tool for your database observability starts with understanding your users and goals. This page helps you confirm whether otelsql fits your needs before you dive into installation or configuration.
</Info>
